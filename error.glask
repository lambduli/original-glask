module Main where
{ class Num a where
  { (-) :: a -> a -> a }

; instance Num Int where
  { (-) x y = int#- (x, y) }

-- ; instance Num Double

-- ; instance (Num a, Num b) => Num (a, b) where
--   { (-) (a, b) (c, d) = (a - c, b - d) }

; instance (Num a, Num b) => Num (Pair a b) where
  { (-) (P a b) (P c d) = P (a - c) (b - d) }

; data Pair a b = P a b

; infixr 2 ||
; infix 4 <=
; infixl 6 -

; data Bool = True | False
; (||) :: Bool -> Bool -> Bool
; (||) True _     = True
; (||) _    True  = True
; (||) _    _     = False

; class Ord a where
  { (<=) :: a -> a -> Bool }

; instance Ord Int where
  { (<=) x y = int#< (x, y) || int#== (x, y) }
  
-- ; class Test a where
--   { test :: a -> a -> a }

-- this used to break down for the let zzz
-- because when predicates contain skolems, it needs to correctly split them too
--
-- ; foo :: Test a => a -> a -> ()
-- ; foo a a' =
--     let { zzz :: x -> x
--         ; zzz o = let { q = test a a' } in o }
--   in ()

-- this is the same problem
--
--
-- ; foo :: Test (m a) => m a -> m a -> ()
-- ; foo a a' =
--     let { zzz :: x -> x
--         ; zzz o = let { q = test a a' } in o }
--   in ()


-- this whole file illustrates the limiations of my current "placeholder elimination" approach
-- because I do eliminate going from the bottom up
-- when I try to eliminate the most nested let's placeholder
-- the corresponding Test dictionary is not in the scope yet

-- I am pretty sure the future, beter approach
-- which works like this:
-- AST ---> Typed AST ---eliminate placeholders/desugar overloadings---> Simple AST


-- the important part is - the new split'
-- should work even with scoped type variables


-- used to not work (because I have not implemented it) but now it works (because I just did)
-- ; data Rec a = Rec { x :: Int, y :: a }
-- ; rec1 = Rec{ x = 23, y = 'a' }
-- ; justX Rec{ x = x } = x



-- ze souboru "tohle prozkoumej" na g drive
-- does not work without the type annotation
-- ; foo :: (a, Int) -> Int
-- ; foo (x, n)
--   = if n <= 0
--     then foo ('c', n - 1)
--     else foo (True, n - 2)

-- ; bar :: Bool -> p -- works with the anotation too
-- ; bar x = if x then bar x else bar x


-- this does not work because elimination on tuples is not implemented yet
-- ; func x = (x, x) - (x, x)

-- just checking that it would work with user-tuples
; func' x = P x x - P x x

}