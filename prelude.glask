module Main where
{ 
  class Num a

; instance Num Int
; instance Num Double


; class Fractional a

; instance Fractional Double


-- ; data Malformed = One a -- this is incorrect

; data Phantom a = Ph

; data Maybe a = Nothing | Just a

; data Test m a = Constr (m a)

-- ; data Record m a = Rec { a :: Int, b :: Maybe a } -- tohle z nejakyho duvodu priradi `m`ku kind (? -> ?)
-- ; data Record m a = Rec { a :: Int, b :: Maybe a, c :: m a } -- tady je v poradky ze `m` :: (* -> *)
; data Record m a = Rec { a :: Int, b :: Maybe a, c :: m a } -- tady je v poradky ze `m` :: (* -> *)


-- Now I want to try to create a malformed class section
-- ; class A m where
--   { x :: m a } -- this should assert that A's type parameter must be * -> *
-- ; class B a where
--   { y :: A a => a } -- this should break it -- A was used with `b` which obviously has kind *


-- Now I want to try to create a method which abstracts over some type variables involved in Class Constraints and Type constructors
; class Z a where
  { zzz :: Higher a => b -> b -- this should make the (a :: * -> *)
  ; xxx :: b -> Test a b } -- this should make the (a :: * -> *, b :: *)
-- THIS WORKS NOW


--  NOW I WANT TO TRY SOME MALFORMED TYPE ANNOTATIONS
-- ; malformed :: forall . Maybe -- this indeed fails to type check - the right side of the `.` has not a kind *
-- ; malformed = malformed
-- THIS FAILS BECAUSE (forall . Maybe) IS NOT UNIFIABLE WITH Maybe
-- ; fails :: (forall . Maybe) Int
-- ; fails = Just 23
-- THIS SHOULD ALSO FAIL
-- ; data Ex = Ex (forall . Maybe)



-- TESTING KIND INFERENCE WITHIN EXPLICIT ANNOTATIONS
; class Higher m where
  { pure :: a -> m a }
-- ; data AlsoHigher m = Also (m Int)
-- ; illegal :: Higher m => m -> a -> a -- this is rejected - because `m` can't be both * and * -> *
-- ; illegal = illegal

-- ; also'illegal :: AlsoHigher x -> x -> Int -- this is rejected - because `x` can't be both * and * -> *
-- ; also'illegal = also'illegal



; class () => Foo a where
  {
  foo :: (a -> b) -> a -> b
  -- ; foo x y = x
  ; bar :: (a -> b a) -> a -> b a
  }


-- ; instance (Show a) => Baz ([] a) where
-- { baz = 23 :: a }
  
-- ; type Foo = Int -- Type Aliases/Synonym expansion is not implemented yet
  
; int = 23 -- I have fixed the bug manifesting for this declaration
; double = 23.7

; expl :: Double
; expl = 23

; lambda = \ a b c -> c

; fn :: a -> b -> c -> c
; fn = \ a b c -> c


; undefined = undefined

; oog :: m a -> (a -> b) -> m b
; oog = undefined


; require :: Num a => a -> a
; require = \ x -> x

; ok = require 23

-- ; not'ok = require 'a'



; expl'forall :: forall m a b . (a -> m b) -> a -> m b
; expl'forall = \ fn a -> fn a


}
