module Main where
{ 
  class Num a

; instance Num Int
; instance Num Double


; class Fractional a

; instance Fractional Double


; data Maybe a = Nothing | Just a

-- ; data Record m a = Rec { a :: Int, b :: Maybe a } -- tohle z nejakyho duvodu priradi `m`ku kind (? -> ?)
-- ; data Record m a = Rec { a :: Int, b :: Maybe a, c :: m a } -- tady je v poradky ze `m` :: (* -> *)
; data Record m a = Rec { a :: Int, b :: Maybe a, c :: m a } -- tady je v poradky ze `m` :: (* -> *)



; class Higher m where
  { pure :: a -> m a }

; illegal :: Higher m => m -> a -> a -- this should be illegal, because `m` is supposed to be of kind * -> * and that means it can't stand as an argument to the function
; illegal = illegal
-- TODO: I need to fix this.

; class () => Foo a where
  {
  foo :: (a -> b) -> a -> b
  -- ; foo x y = x
  ; bar :: (a -> b a) -> a -> b a
  }


-- ; instance (Show a) => Baz ([] a) where
-- { baz = 23 :: a }
  
-- ; type Foo = Int -- Type Aliases/Synonym expansion is not implemented yet
  
; int = 23 -- I have fixed the bug manifesting for this declaration
; double = 23.7

; expl :: Double
; expl = 23

; lambda = \ a b c -> c

; fn :: a -> b -> c -> c
; fn = \ a b c -> c



; oog :: m a -> (a -> b) -> m b
; oog = undefined


; require :: Num a => a -> a
; require = \ x -> x

; ok = require 23

-- ; not'ok = require 'a'

; undefined = undefined


; expl'forall :: forall m a b . (a -> m b) -> a -> m b
; expl'forall = \ fn a -> fn a


}
