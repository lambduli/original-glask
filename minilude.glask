module Main where
{ infixr 0 $
; infixl 5 +
; infixl 6 *

; class Num a where
  { (+) :: a -> a -> a
  ; (*) :: a -> a -> a }

; instance Num Int
-- ; instance Num Double


-- ; class Fractional a

-- ; instance Fractional Double

-- ; data String = String [Char]

-- ; class Show a where
--   { show :: a -> String }


; data Bool = True | False

; data Maybe a = Nothing | Just a

-- ; number :: Int
-- ; number = 23

-- ; fnum :: Num a => a -> a
-- ; fnum = \ a -> a
-- 
-- ; gnum :: Num a => a -> a -> a
-- ; gnum = \ x y -> fnum x

-- ; cool'num 23 = True
-- ; cool'num 42 = True
-- ; cool'num _ = False

-- ; inter True 23 = 'a'
-- ; inter False 42 = 'a'
-- ; inter _ _ = 'z'

-- ; foo fn True = fn True

-- ; bar :: (x -> b) -> x -> b
-- ; bar fn a = fn a


; ($) :: (a -> b) -> a -> b
-- -- ; ($) = \ fn a -> fn a
; ($) fn a = fn a
-- 
-- ; tttest = cool'num $ 23 + 42


-- ; loc :: Maybe a -> Maybe Int
-- ; loc (Just a) = Just 23


-- ; undefined = undefined


; fn'om :: Num a => b -> a
; fn'om x = 23

; arg = arg
; n     = fn'om arg
-- TODO: this break without the parens
-- either I have a bug in the type checker or I have an bug in the To'AST (GSYA)
; twice _ = fn'om arg + fn'om arg

}
