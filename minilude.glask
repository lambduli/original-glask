module Main where
{ infixr 0 $
; infixl 5 +
; infixl 6 *

; class Num a where
  { (+) :: a -> a -> a
  ; (*) :: a -> a -> a }

; instance Num Int
; instance Num Double

; class Num a => Fractional a

; instance Fractional Double




-- THIS BREAKS WITHOUT THE EXPLICIT ANNOTATION FOR `def`
-- ; data Unit = Unit
-- ; class Cals a where
--   { call :: a -> a -> a }
-- ; def :: Int
-- ; def = 23
-- ; instance Cals Int where
--   { call a b = a }
-- ; typed :: Unit -> Unit
-- ; typed _ = let { x = call def def } in Unit






-- ; data String = String [Char]

-- ; class Show a where
--   { show :: a -> String }

-- THIS IS SUPPOSED TO FAIL, and it does now
; fail :: Num a => a -> a -> a
; fail a b = a + b
-- ; xxx = fail 'a' 'b' -- Char is not an instance of Num
-- ; yyy _ = fail True False -- Bool is not an instance of Num
; zzz = fail 23 42

-- -- all works as described
-- ; data Carry = C (forall a . Num a => a -> a -> a)
-- -- ; fail' (C fn) = fn 'c' 'a' -- this correctly fails
-- ; fail'' :: Carry -> a -> a -> a -- context is too weak so it correctly fails
-- ; fail'' (C fn) x y = fn x y -- without annotation if correctly infers Num

--
; data Fun = F (forall a . Num a => a -> a -> a)
-- ; fa (F fn) = fn 'a' 'b' -- this correctly fails because Char is not an instance of Num
; fb (F fn) = fn (23 :: Int) (42 :: Int)


; data Bool = True | False

; data Maybe a = Nothing | Just a

-- ; number :: Int
-- ; number = 23

-- ; fnum :: Num a => a -> a
-- ; fnum = \ a -> a
-- 
-- ; gnum :: Num a => a -> a -> a
-- ; gnum = \ x y -> fnum x

-- ; cool'num 23 = True
-- ; cool'num 42 = True
-- ; cool'num _ = False

-- ; inter True 23 = 'a'
-- ; inter False 42 = 'a'
-- ; inter _ _ = 'z'

-- ; foo fn True = fn True

-- ; bar :: (x -> b) -> x -> b
-- ; bar fn a = fn a


-- ; ($) :: (a -> b) -> a -> b
-- -- -- ; ($) = \ fn a -> fn a
-- ; ($) fn a = fn a
-- -- 
-- -- ; tttest = cool'num $ 23 + 42


-- ; loc :: Maybe a -> Maybe Int
-- ; loc (Just a) = Just 23


-- ; undefined = undefined


-- ; fn'om :: Num a => b -> a
-- ; fn'om x = 23

-- ; arg = arg
-- ; n     = fn'om arg
-- TODO: this break without the parens
-- either I have a bug in the type checker or I have an bug in the To'AST (GSYA)
-- ; twice _ = fn'om arg + fn'om arg





}
